---
title: "Un petit coup de polish Nettoyage de fichiers Excel avec R"
subtitle: "Rencontres R 2024"
author: "Thomas Vroylandt, Kantiles"
format: 
  revealjs:
    theme: "assets/custom.scss"
filters: [assets/bg_inverse.lua]
execute: 
  echo: true
  message: false
  warning: false
---

## Données et slides

[{{< fa paperclip >}} https://github.com/tvroylandt/rr_2024](https://github.com/tvroylandt/rr_2024)

![](img/qr_code_rr_excel.png)

## Qui suis-je ?

:::: {.columns}
::: {.column width="40%" .fragment .fade-in}

:::{.small-box-img}

![](img/thomas.jpeg){.round-img}
:::

**Thomas Vroylandt**

Associé (Kantiles)
[thomas@kantiles.com](mailto:thomas@kantiles.com)
:::

::: {.column width="60%" .fragment .fade-in}

- Rapports statistiques
- Chaîne de production
- Politiques sociales et de l'emploi

{{< fa arrow-right >}} Cas réels, dans le cadre de production d'indicateurs pour un service statistique ministériel

:::
::::

## Que demande le peuple ?

![](img/tidydata.jpeg){width="300"}

:::source
Source : Allison Horst [{{< fa paperclip >}}](https://openscapes.org/blog/2020-10-12-tidy-data/)
:::

## De l'autre côté du miroir

![](img/excel_meme.jpeg){width="300"}

## De l'autre côté du miroir

Une grande créativité dans les mises en forme des données !

Captures d'écrans qui se superpose de fichiers Excel en bordel avec smileys de réactions

## Boîte à outils {{< fa screwdriver-wrench >}}

- [`readxl`](https://readxl.tidyverse.org/) : import de fichiers rectangulaires simples

- [`tidyxl`](https://github.com/nacnudus/tidyxl/) : permet de transformer l'étape d'import en une étape de nettoyage de données

- [`unpivotr`](https://github.com/nacnudus/unpivotr/) : complément de `tidyxl` pour le nettoyage

- A mentionner : [`openxlsx2`](https://github.com/JanMarvin/openxlsx2) (sert aussi en écriture)

```{r}
library(tidyverse)
library(readxl)
library(tidyxl)
library(unpivotr)
```


## Insee - Taux d'activité

Population active et taux d'activité au sens du recensement selon le sexe et l'âge en 2020 : comparaisons départementales [{{< fa paperclip >}}](https://www.insee.fr/fr/statistiques/2012710)

![](img/insee_activite_0.png){width="300"}

## Insee - Taux d'activité

Intitulés des colonnes fusionnées

![](img/insee_activite_1.png){width="300"}

## Insee - Taux d'activité

Zone des données décalée

![](img/insee_activite_2.png){width="300"}

## Insee - Taux d'activité - `readxl`

Option 1 en listant les noms de colonne

## Insee - Taux d'activité - `readxl`

Option 2 en faisant deux passes comme dans la  [vignette](https://readxl.tidyverse.org/articles/multiple-header-rows.html)

## Insee - Taux d'activité - `tidyxl` + `unpivotr`

```{r}
xlsx_cells("data/TCRD_015.xlsx") |>
  filter(sheet == "DEP" & row >= 3) |>
  behead("up-left", "typ_var") |>
  behead("up", "mod_var") |>
  behead("left", "code_dep") |>
  behead("left", "lib_dep") |>
  select(typ_var, mod_var, code_dep, lib_dep, numeric)
```

## Drees - ISD C24

Répartition des naissances par âge de la mère [{{< fa paperclip >}}](https://data.drees.solidarites-sante.gouv.fr/explore/dataset/601_indicateurs-de-contexte/information/)

![](img/c24_0.png){width="300"}

## Drees - ISD C24

Début des données décalées

![](img/c24_1.png){width="300"}

## Drees - ISD C24

Intitulés des colonnes fusionnées

![](img/c24_2.png){width="300"}

## Drees - ISD C24

Un onglet par année (mais tous pareil) + un onglet de documentation

![](img/c24_3.png){width="300"}

## Drees - ISD C24

Des données à la fin que l'on ne souhaite pas importer

![](img/c24_4.png){width="300"}

## Drees - ISD C24 - `readxl`

reprendre la fonction et ses arguments un par un

faire avec code + résultat an face à face avec highlight

sheet nommé ou en position
range ou skip, ici on fait un skip et on gérera derrière, mais un range peut permettre de sortir direct les lignes du bas. Aussi n_max

on peut aussi spécifier à la main un vecteur de noms, ou skip des colonnes avec col_types

```{r}
path_c24 <- "data/C24-ISD_Part_accouchements_selon_age_mere.xlsx"

df_c24_init <-
  read_xlsx(path_c24,
            sheet = "2022",
            skip = 5,
            .name_repair = "unique_quiet") |>
  rename(code_dep = ...1,
         lib_dep = ...2) |>
  pivot_longer(-c(code_dep, lib_dep),
               names_to = "age_mere",
               values_to = "perc_naiss")

```

## Drees - ISD C24 - `readxl`

Puis on fait une fonction sur les onglets
On peut aussi gérer dans une custom fonction si on a du wrangling à faire avant
Des fois il faut aussi passer un as.character sur l'ensemble avant le pivot puis gérer les cas

```{r}
df_c24_full <- excel_sheets(path_c24) |>
  set_names() |>
  # remove documentation sheet
  _[-12] |>
  map(read_xlsx,
      path = path_c24,
      skip = 5,
      .name_repair = "unique_quiet") |>
  list_rbind(names_to = "annee") |>
  rename(code_dep = ...1,
         lib_dep = ...2) |>
  pivot_longer(-c(annee, code_dep, lib_dep),
               names_to = "age_mere",
               values_to = "perc_naiss") |> 
  mutate( annee = as.numeric(annee)) |> 
  filter(!is.na(code_dep) & !is.na(perc_naiss) & !code_dep %in% c("F", "M"))

df_c24_full
```

## Drees - ISD C24 - `tidyxl`

```{r}
df_cells_c24 <- xlsx_cells(path_c24)

df_cells_c24
```

## Drees - ISD C24 - `tidyxl` + `dplyr`/`tidyr` 

Soit on peut gérer à la main, en considérant que le contenu est numerique et le reste du character, on va fill puis pivot
puis gérer sur les colonnes

Un peu artisanal mais ça passe

```{r}
df_c24_cells_full <- df_cells_c24 |>
  filter(sheet != "Documentation") |>
  filter(row >= 4 & !is_blank & col != 2) |>
  select(sheet, row, col, character, numeric) |>
  # on construit lignes et colonnes
  mutate(header_row = case_when(row == 6 ~ character),
         code_dep = case_when(col == 1 ~ coalesce(as.character(numeric), character))) |>
  # fill des colonnes
  group_by(col) |>
  fill(header_row, .direction = "down") |>
  # fill des codes dep
  group_by(row) |>
  fill(code_dep, .direction = "down") |>
  ungroup() |>
  # on filtre
  filter(!is.na(numeric) &
           !is.na(code_dep) &
           !is.na(header_row) & !code_dep %in% c("F", "M")) |>
  mutate(sheet = as.numeric(sheet),
         header_row = str_trim(header_row)) |>
  select(annee = sheet,
         code_dep,
         age_mere = header_row,
         perc_naiss = numeric)
```

## Drees - ISD C24 - `tidyxl` + `unpivotr` 

penser à grouper par onglet

-> fonctions très puissantes mais pas toujours faciles à manipuler

up-left car une cellule fusionnée ne remplit en fait que la première valeur en haut à gauche
-> exemple capture d'écran

```{r}
df_cells_c24 |>
  filter(row >= 5) |>
  group_by(sheet) |>
  behead("up-left", "typ_var") |>
  behead("up", "mod_var") |>
  behead("left", "code_dep") |>
  behead("left", "lib_dep") |>
  ungroup() |>
  mutate(mod_var = str_trim(mod_var)) |> 
  select(sheet, typ_var, mod_var, code_dep, lib_dep, numeric) |>
  filter(!is.na(code_dep) &
           !code_dep %in% c("F", "M") &
           !is.na(numeric)) 
```

Faire des schéma étapes par étape

Fira Code
Importer les polices
Mettre sur ipad
Voir ce qu'on peut faire niveau code dans Quarto (extensions ?)

## Résultat, avec Observable [{{< fa paperclip >}}](https://github.com/kantiles/demo_isd)

<iframe src="https://kantiles.github.io/demo_isd/main.html"  width="1200" height="700"></iframe>

## Quelques astuces

- on peut paramétriser le nombre de lignes à sauter par onglet (dans le filter), car cela arrive que les espacements ne soient pas les mêmes d'une année sur l'autre
- penser à utiliser les fonctions de `dplyr` et `tidyr` comme `fill` ou `coalesce` en complément
- séparer par bloc + faire des `str_detect`

exemple pour récupérer les dates de MAJ de chaque onglet

```{r}
df_cells_c24 |>
  select(sheet, character) |>
  filter(str_detect(character, "mise à jour")) |>
  mutate(
    date_maj = str_remove(character, "Date de mise à jour : "),
    date_maj = dmy(date_maj)
  )
```

## FAJ - Dernier exemple sur le sujet

[{{< fa paperclip >}}](https://data.drees.solidarites-sante.gouv.fr/explore/dataset/374_le-fond-d-aide-aux-jeunes-faj/information/)

Cela fonctionne dans la plupart des cas assez bien, même avec des cellules fusionnées et d'autres non

petite subtilité car tous les onglets ne commencent pas au même endroit et ne terminent pas au même endroit

```{r}
df_cells_faj <- xlsx_cells("data/FAJ Données annuelles 2007-2022.xlsx") |>
  # on filtre sur les onglets qui nous intéressent - on retire FAJ2015 qui a une structuration différente et qu'il faudrait traiter à part
  filter(str_sub(sheet, 1, 6) == "FAJ 20" & sheet != "FAJ 2015")

# ligne de début
df_cells_faj_min <- df_cells_faj |> 
  filter(character == "Départements") |> 
  select(sheet, row_min = row)

# ligne de fin - on aurait aussi pu détecter La Réunion
df_cells_faj_max <- df_cells_faj |> 
  filter(is_blank & col == 1) |> 
  inner_join(df_cells_faj_min, by = join_by(sheet)) |> 
  # on ajoute quelques lignes
  filter(row > row_min + 3) |> 
  group_by(sheet) |> 
  filter(row == min(row)) |>
  ungroup() |> 
  select(sheet, row_max = row) |>
  # comme on a detecté la ligne blanche suivant la fin, on décale
  mutate(row_max = row_max - 1)

# on jointe pour cibler les tableaux
df_cells_faj |>
  inner_join(df_cells_faj_min, by = join_by(sheet)) |>
  inner_join(df_cells_faj_max, by = join_by(sheet)) |>
  filter(between(row, row_min, row_max)) |>
  group_by(sheet) |>
  behead("up-left", "typ_var") |>
  behead("up", "mod_var") |>
  behead("left", "code_dep") |>
  behead("left", "lib_dep") |>
  ungroup() |>
  select(sheet, typ_var, mod_var, code_dep, lib_dep, character, numeric)
```

## En v2 FAJ - partitions

Tab 2022 avec deux tabs dans le même --> séparation des tabs plutôt que de ne faire que le premier

on va partitionner les cellules en tableaux, comme un nest, puis on va pouvoir soit travailler indépendemment, soit avec un map si la structure est similaire travailler le sujet

pour cela, il va falloir délimiter, ici on va le faire par les en-têtes, mais cela peut aussi se faire avec une détection des blancs (mais plus complexe avec les cellules fusionnées)

```{r}
df_cells_faj_filtered <- df_cells_faj |>
  filter(sheet == "FAJ 2022" & row >= 9)

df_title_cells_faj <- df_cells_faj_filtered |>
  filter(character %in% c("Départements", "Métropoles et départements hors métropoles"))

# on partitionne
partitions_faj <- partition(df_cells_faj_filtered,
          df_title_cells_faj)

# on reprendre le code du dessus
# et on assemble
map(
  partitions_faj$cells,
  \(data) data |>
    behead("up-left", "typ_var") |>
    behead("up", "mod_var") |>
    behead("left", "code_dep") |>
    behead("left", "lib_dep") |>
    select(typ_var, mod_var, code_dep, lib_dep, character, numeric)
) |>
  set_names("dep", "metro") |>
  list_rbind(names_to = "type_geo")
```

## Panorama statistique

[{{< fa paperclip >}}](https://drees.solidarites-sante.gouv.fr/sites/default/files/panorama/telechargement.htm)

démo pour le format sous une autre forme que le texte (gras, couleur)

On va s'attacher à un seul tableau

```{r}
#| echo: false
knitr::include_graphics("img/panorama_0.png")
```

## Panorama statistique

```{r}
path_panorama <- "data/PanoFrance2022.xlsx"

# chargement des cellules + délimitation
df_cells_panorama <- xlsx_cells(path_panorama) |> 
  filter(between(row, 330, 355))

# et du format - liste
format_panorama <- xlsx_formats(path_panorama)

df_panorama_cleaned <- df_cells_panorama |>
  # il faudra gérer la fusion des codes géographiques à part
  behead("up", "code_geo") |>
  # type d'établissement en gras - penser à indexer sur le type d'établissement
  behead_if(format_panorama$local$font$bold[local_format_id],
            direction = "left-up",
            name =  "type_etab") |>
  behead_if(
    format_panorama$local$alignment$indent[local_format_id] == 2,
    direction = "left-up",
    name =  "type_var"
  ) |>
  behead_if(
    format_panorama$local$alignment$indent[local_format_id] == 4,
    direction = "left",
    name =  "type_places"
  ) |>
  select(code_geo, type_etab, type_var, type_places, numeric, character) |> 
  filter(!is.na(numeric))

df_panorama_cleaned
```

## Quelques astuces

- ne pas hésiter à coder à la main des choses, tout ne peut pas être automatisé (enfin, tout peut l'être, mais il faut doser le coût-bénéfice)
- de façon générale, une formattage = un code
- faire plusieurs passes, par exemple pour se faire un fichier de référence des noms de colonnes utilisables derrière
- ce n'est que de la manip de données
- on peut aussi faire sur plusieurs fichiers Excel à la fois si ils sont formattés pareil
- privilégier quand c'est possible d'autres exports (c'est souvent le cas notamment en open data avec le paramétrage OpenDataSoft qui force + parquet)

## Questions ?



:::: {.columns}

::: {.column width="50%" .fragment .fade-in-then-semi-out}
::: {.small-box style="background: #FE7920;"}
Production statistique
:::
:::

::: {.column width="50%" .fragment .fade-in-then-semi-out}
::: {.small-box style="background: #074d60;"}
Rapports statistiques
:::
:::

::::

:::: {.columns}
::: {.column width="50%" .fragment .fade-in-then-semi-out}
::: {.small-box style="background: #D93930;"}
Politiques sociales et de l'emploi
:::
:::

::: {.column width="50%" .fragment .fade-in-then-semi-out}
::: {.small-box style="background: #008A71;"}
Handicap
:::
:::

::::

## Caractéristiques

::: {.wide-box .fragment .fade-in}
{{< fa circle-chevron-down size=xl >}}
Récupération des données
:::
::: {.wide-box .fragment .fade-in}
{{< fa circle-chevron-down size=xl >}}
Calcul des indicateurs
:::
::: {.wide-box .fragment .fade-in}
{{< fa circle-chevron-down size=xl >}}
Mise en forme des fichiers
:::
::: {.wide-box .fragment .fade-in}
{{< fa circle-chevron-down size=xl >}}
Validation
:::
::: {.wide-box .fragment .fade-in}
{{< fa circle-chevron-down size=xl >}}
Documentation
:::
::: {.wide-box .fragment .fade-in}
{{< fa circle-chevron-down size=xl >}}
Mise en ligne
:::
   
